    １機能分解
    機能A(テキストの一行目を返すだけ)
    改行文字までの文字列をマロックで確保して返す
    改行文字が見つからない時はどうする？
    もう一回同じ作業を繰り返す。
    見つかったらどうする？
    文字列を連結して改行文字までをマロックで確保して文字列を返す。
    return(* 先頭の文字〜改行文字＋ヌル文字)
    
    機能B(二回目以降の呼び出しで次の’行’が返される)
    最初はいいとして、じゃあ、次の先頭文字はどうやって手に入れる？
    buff[9]とする。
    abcde
    fghij と言うテキストがあるとすると
    *buff=abcde\nfghij という文字列が読み込まれる。
    確保する文字列は　returnはaからeまで+\0
    二回目の呼び出しではfghijが返ってこないといけない
    改行文字の次のポインタからbuffの最後までをstatic charで確保して保管(文字列a)
    二回目の呼び出しでbuffに保管されたb文字列とa文字列をjoin（結合）する
    文字列aの中にも改行文字が入ってる可能性があるので二回目の呼び出しをした時は最初にaを走査してチェック
    見つかれば機能Aに移る
    見つからない時は、再度readで読み込んでjoinする。

    ２構成
    改行文字まで文字列を読み込み、改行までの文字列を返す。
    その後に改行文字以降の文字列を、次にbuffから読み込む文字列と接続しようとしたがうまくいかないので練り直し、
    同時にやる量を減らす。

    ①改行文字までを含む文字列①を作成する、
    ②①で作成した文字列を改行文字までの文字列に作り直す。
    ③①で作成した文字列を改行文字以降に作り直す。
    ④③で作成した文字列を①に渡す。

    ３クローズ
    ①
    buffのサイズで読み込んで、改行文字が見つからなければ再度読み込んで最初の文字列と繋げる
    （buff）のコピー先は最初から動的メモリがいいかも
    return(\nを含む文字列)

    ②
    ①で作成した文字列を\nになるまでカウントしてその長さでマロック確保しコピーするだけ
    return(\nまでの文字列)
    このreturnはgnl本体の戻り値でも使う

    ③
    ①で作成した文字列の\nまでのカウントをiとして、①の文字列の長さ-iでマロック確保、
    動的メモリの中に②のカウント＋１のインデックス文字を代入していく。

    ④
    ③で作成した文字列を①で受け取れるようにする。（static?））

